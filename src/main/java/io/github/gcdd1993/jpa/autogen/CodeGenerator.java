package io.github.gcdd1993.jpa.autogen;

import io.github.gcdd1993.jpa.autogen.config.CodeGeneratorConfig;
import io.github.gcdd1993.jpa.autogen.config.ModuleConfig;
import io.github.gcdd1993.jpa.autogen.model.EntityInfo;
import io.github.gcdd1993.jpa.autogen.render.BaseRender;
import io.github.gcdd1993.jpa.autogen.render.IRender;
import io.github.gcdd1993.jpa.autogen.util.ReflectUtils;

import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;
import java.util.stream.Collectors;

/**
 * TODO
 *
 * @author gaochen
 * Created on 2019/6/18.
 */
public class CodeGenerator {

    private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy/MM/dd");

    private static final String SRC_PATH = "src/main/";

    private CodeGeneratorConfig config;

    private List<IRender> renderList = new LinkedList<>();

    public CodeGenerator(String configLocation) {
        Properties properties = new Properties();
        try {
            properties.load(CodeGenerator.class.getResourceAsStream(configLocation));

            config = new CodeGeneratorConfig();
            config.setAuthor(properties.getProperty("author", System.getProperty("user.name")));
            config.setEntityPackage(properties.getProperty("entity.package"));
            config.setComments(properties.getProperty("comments", "code generated by jpa codegen"));
            config.setDate(DATE_TIME_FORMATTER.format(LocalDate.now()));
            config.setFtlPath(properties.getProperty("template.dir", SRC_PATH + "resources/template/"));
            config.setForceOverride(Boolean.parseBoolean(properties.getProperty("forceOverride", "false")));

            ModuleConfig repository = parseModuleConfig("repository", properties);
            ModuleConfig service = parseModuleConfig("service", properties);
            ModuleConfig form = parseModuleConfig("form", properties);
            ModuleConfig controller = parseModuleConfig("controller", properties);

            config.setRepository(repository);
            config.setService(service);
            config.setForm(form);
            config.setController(controller);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 解析模块配置
     *
     * @param module 模块
     * @return 模块配置
     */
    private ModuleConfig parseModuleConfig(String module, Properties properties) {
        ModuleConfig moduleConfig = new ModuleConfig();
        moduleConfig.setClassNameSuffix(properties.getProperty(module + ".class.suffix",
                module.substring(0, 1).toUpperCase().concat(module.substring(1))));
        moduleConfig.setFtlName(config.getFtlPath() + properties.getProperty(module + ".ftlName", module + ".ftl"));

        String packageName = properties.getProperty(module + ".package", properties.getProperty("entity.package") + "." + module);
        moduleConfig.setPackageName(packageName);

        moduleConfig.setSavePath(SRC_PATH + "java/" + packageName.replace(".", "/") + "/");

        return moduleConfig;
    }

    public void generate() {
        List<Class<?>> entityClasses = ReflectUtils.getClassListByAnnotation(config.getEntityPackage(), "javax.persistence.Entity");
        List<EntityInfo> entityInfos = entityClasses.stream().map(EntityInfo::buildFromEntity).collect(Collectors.toList());
        entityInfos.forEach(entityInfo ->
                renderList.forEach(render -> render.render(entityInfo)));
    }

    /**
     * 注册渲染组件
     *
     * @param renderClass 渲染组件类
     */
    public CodeGenerator registerRender(Class<? extends BaseRender> renderClass) {
        try {
            Constructor<? extends IRender> renderClassConstructor = renderClass.getConstructor(CodeGeneratorConfig.class);
            IRender render = renderClassConstructor.newInstance(config);
            renderList.add(render);
            return this;
        } catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }

}
